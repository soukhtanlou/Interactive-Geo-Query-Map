<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù†Ù‚Ø´Ù‡ Ø®Ø¯Ù…Ø§Øª Ø¶Ø±ÙˆØ±ÛŒ Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ (Social Amenities Map)</title>
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Leaflet CSS for map display -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/SDAf/GPGDeQvVzHME="
          crossorigin=""/>
    <style>
        /* Custom styles for the map container and full screen layout */
        body, html {
            height: 100%;
            margin: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent body scroll */
        }
        #map {
            height: calc(100vh - 12rem); /* Adjust height based on header/footer size */
            min-height: 400px;
            width: 100%;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        /* Custom styles for the result summary box */
        .summary-box {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            font-size: 0.9rem;
            max-width: 90%;
            transition: opacity 0.3s;
        }
        .summary-box.hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body class="bg-gray-50 flex flex-col h-screen">

    <header class="p-4 bg-white shadow-md">
        <h1 class="text-2xl font-bold text-blue-700">Ø¬Ø³ØªØ¬ÙˆÛŒ Ø®Ø¯Ù…Ø§Øª Ø¶Ø±ÙˆØ±ÛŒ Ù…Ù†Ø·Ø¨Ù‚ Ø¨Ø§ Ù…Ø§Ù…ÙˆØ±ÛŒØª ÛŒÙˆÙ†ÛŒØ³Ù</h1>
        <p class="text-sm text-gray-500">Ù…Ú©Ø§Ù† Ùˆ Ù†ÙˆØ¹ Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² (Ù…Ø§Ù†Ù†Ø¯ Ø¢Ù…ÙˆØ²Ø´ Ùˆ Ø³Ù„Ø§Ù…Øª) Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯ ØªØ§ Ù…Ú©Ø§Ù†â€ŒÙ‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ø¯Ø± Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ù†Ù…Ø§ÛŒØ§Ù† Ø´ÙˆÙ†Ø¯.</p>
    </header>

    <main class="flex-grow p-4 overflow-hidden">
        <div class="flex flex-col lg:flex-row gap-4 mb-4">
            <!-- Location Input -->
            <div class="flex flex-grow items-center space-x-2 space-x-reverse">
                <input type="text" id="locationInput" placeholder="Ù†Ø§Ù… Ø´Ù‡Ø±ØŒ Ù…Ù†Ø·Ù‚Ù‡ ÛŒØ§ Ø®ÛŒØ§Ø¨Ø§Ù† (Ù…Ø«Ù„Ø§Ù‹ ØªÙ‡Ø±Ø§Ù†)" 
                       class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150 shadow-sm">
                <button id="searchLocationButton" 
                        class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg shadow-md transition duration-150 ease-in-out transform hover:scale-[1.01] active:scale-[0.99] disabled:opacity-50"
                        title="Ù†Ù‚Ø´Ù‡ Ø±Ø§ Ø¨Ù‡ Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø¬Ø³ØªØ¬Ùˆ Ø´Ø¯Ù‡ Ù…Ù†ØªÙ‚Ù„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯">
                    Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ú©Ø§Ù†
                </button>
            </div>
        </div>

        <!-- Service Group Buttons (New Feature) -->
        <div class="grid grid-cols-2 md:grid-cols-4 lg:flex lg:flex-wrap gap-2 mb-4">
            <h3 class="font-medium text-gray-700 lg:mr-4 lg:self-center col-span-2 md:col-span-4 lg:col-span-auto">ÛŒØ§ Ø¬Ø³ØªØ¬Ùˆ Ø¨Ø± Ø§Ø³Ø§Ø³ Ú¯Ø±ÙˆÙ‡:</h3>
            <button class="serviceGroupButton bg-green-500 hover:bg-green-600 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition" data-group="Ø¢Ù…ÙˆØ²Ø´">ğŸ“š Ø¢Ù…ÙˆØ²Ø´ Ùˆ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ</button>
            <button class="serviceGroupButton bg-red-500 hover:bg-red-600 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition" data-group="Ø³Ù„Ø§Ù…Øª">ğŸ¥ Ø¨Ù‡Ø¯Ø§Ø´Øª Ùˆ Ø³Ù„Ø§Ù…Øª</button>
            <button class="serviceGroupButton bg-yellow-500 hover:bg-yellow-600 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition" data-group="ØªØºØ°ÛŒÙ‡">ğŸ›’ Ø¢Ø¨ØŒ ØºØ°Ø§ Ùˆ Ù¾Ù†Ø§Ù‡Ú¯Ø§Ù‡</button>
            <button class="serviceGroupButton bg-purple-500 hover:bg-purple-600 text-white font-medium py-2 px-4 rounded-lg shadow-sm transition" data-group="Ø®Ø¯Ù…Ø§Øª_Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ">ğŸ›¡ï¸ Ø®Ø¯Ù…Ø§Øª Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ/Ø­ÙØ§Ø¸Øª</button>
        </div>

        <!-- Map Container -->
        <div id="map" class="shadow-xl"></div>
        
        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="summary-box hidden">
            <div class="flex items-center space-x-2 space-x-reverse">
                <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span class="text-blue-700">Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ú©Ø§Ù†â€ŒÙ‡Ø§...</span>
            </div>
        </div>

        <!-- Result Summary -->
        <div id="resultSummary" class="summary-box hidden text-gray-800"></div>

    </main>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-2Pmvv0kuTBOz8S+U1XF7Cs_v1K3PXYYgEaAU/LZSgC1="
            crossorigin=""></script>

    <script>
        // Set up the Leaflet map
        const map = L.map('map').setView([32.4279, 53.6880], 5); // Default view: Center of Iran

        // Add the base tile layer (OpenStreetMap)
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        let markers = L.layerGroup().addTo(map);
        let currentBoundingBox = null;
        const resultSummary = document.getElementById('resultSummary');
        const locationInput = document.getElementById('locationInput');
        const searchLocationButton = document.getElementById('searchLocationButton');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const serviceGroupButtons = document.querySelectorAll('.serviceGroupButton');
        
        // --- Core UNICEF-Relevant Tag Definitions ---
        // Maps group names to a list of Overpass QL tag queries (e.g., "key=value")
        const UNICEF_TAGS = {
            "Ø¢Ù…ÙˆØ²Ø´": [
                "amenity=school", 
                "amenity=kindergarten",
                "amenity=college",
                "amenity=university",
                "building=school",
                "building=university"
            ],
            "Ø³Ù„Ø§Ù…Øª": [
                "amenity=hospital",
                "amenity=clinic",
                "amenity=doctors",
                "amenity=pharmacy",
                "healthcare=public_health"
            ],
            "ØªØºØ°ÛŒÙ‡": [
                "amenity=feeding_station",
                "amenity=water_point",
                "building=shelter", // Ù¾Ù†Ø§Ù‡Ú¯Ø§Ù‡
                "amenity=market", // Ø¨Ø§Ø²Ø§Ø± (Ø¨Ø±Ø§ÛŒ Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ ØºØ°Ø§)
                "amenity=food_bank"
            ],
            "Ø®Ø¯Ù…Ø§Øª_Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ": [
                "amenity=social_facility", // Ú©Ù„ÛŒÙ‡ Ø®Ø¯Ù…Ø§Øª Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ
                "amenity=childcare", // Ù…Ø±Ø§Ù‚Ø¨Øª Ø§Ø² Ú©ÙˆØ¯Ú©
                "social_facility=orphanage", // ÛŒØªÛŒÙ…â€ŒØ®Ø§Ù†Ù‡ / Ù…Ø±Ø§Ú©Ø² Ù†Ú¯Ù‡Ø¯Ø§Ø±ÛŒ
                "amenity=police", // Ø§Ù…Ù†ÛŒØª Ùˆ Ø­ÙØ§Ø¸Øª
                "amenity=fire_station" // Ø®Ø¯Ù…Ø§Øª Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ
            ]
        };

        // Utility function for exponential backoff retry logic
        async function fetchWithRetry(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.status === 429) {
                        // Too many requests, wait longer
                        const waitTime = Math.pow(2, i) * 1000 + Math.random() * 1000;
                        console.warn(`429 Too Many Requests. Retrying in ${waitTime}ms...`);
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        continue;
                    }
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    const waitTime = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    console.error(`Fetch failed. Retrying in ${waitTime}ms...`, error);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
        }

        // --- Geocoding Function (Location to Coordinates) ---
        async function geocodeLocation(locationName) {
            loadingIndicator.classList.remove('hidden');
            const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(locationName)}&format=json&limit=1`;
            try {
                const response = await fetchWithRetry(url);
                const data = await response.json();
                loadingIndicator.classList.add('hidden');

                if (data && data.length > 0) {
                    const place = data[0];
                    const bbox = place.boundingbox.map(Number); // [minLat, maxLat, minLon, maxLon]
                    currentBoundingBox = [bbox[0], bbox[2], bbox[1], bbox[3]]; // [S, W, N, E]
                    const lat = parseFloat(place.lat);
                    const lon = parseFloat(place.lon);
                    
                    // Move map to the found location bounds
                    map.fitBounds([
                        [bbox[0], bbox[2]], // SW
                        [bbox[1], bbox[3]]  // NE
                    ]);

                    resultSummary.classList.remove('hidden');
                    resultSummary.innerHTML = `<strong>Ù…Ø­Ø¯ÙˆØ¯Ù‡ ÛŒØ§ÙØª Ø´Ø¯:</strong> ${place.display_name}`;
                    return true;
                } else {
                    resultSummary.classList.remove('hidden');
                    resultSummary.innerHTML = `<strong class="text-red-600">Ø®Ø·Ø§:</strong> Ù…Ú©Ø§Ù† '${locationName}' ÛŒØ§ÙØª Ù†Ø´Ø¯.`;
                    return false;
                }
            } catch (error) {
                loadingIndicator.classList.add('hidden');
                resultSummary.classList.remove('hidden');
                resultSummary.innerHTML = `<strong class="text-red-600">Ø®Ø·Ø§ Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ Ù…Ú©Ø§Ù†:</strong> Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.`;
                console.error("Geocoding Error:", error);
                return false;
            }
        }

        // --- Overpass Query Builder ---
        function buildOverpassQuery(tags, bbox) {
            const [minLat, minLon, maxLat, maxLon] = bbox;
            const bboxString = `${minLat},${minLon},${maxLat},${maxLon}`;
            
            // Build the core query for all nodes and ways (areas) matching the tags
            const queryBody = tags.map(tag => {
                const [key, value] = tag.split('=');
                // Query for nodes (points) and ways (polygons)
                return `node[${key}="${value}"](${bboxString});
                        way[${key}="${value}"](${bboxString});`;
            }).join('\n');

            // Combine into the final Overpass QL query
            const query = `
                [out:json][timeout:60];
                (
                    ${queryBody}
                );
                out center;
            `;
            console.log("Generated Overpass Query:", query);
            return query;
        }

        // --- Data Fetching Function (Overpass API) ---
        async function fetchOSMData(tags, groupName) {
            if (!currentBoundingBox) {
                resultSummary.classList.remove('hidden');
                resultSummary.innerHTML = `<strong class="text-red-600">Ø®Ø·Ø§:</strong> Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Ù…Ú©Ø§Ù† Ø±Ø§ Ø¬Ø³ØªØ¬Ùˆ Ú©Ù†ÛŒØ¯.`;
                return;
            }

            // Clear previous markers and show loading
            markers.clearLayers();
            loadingIndicator.classList.remove('hidden');
            resultSummary.classList.add('hidden');
            
            const query = buildOverpassQuery(tags, currentBoundingBox);
            const apiUrl = 'https://overpass-api.de/api/interpreter';
            
            try {
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: `data=${encodeURIComponent(query)}`
                });
                
                const data = await response.json();
                loadingIndicator.classList.add('hidden');
                
                let foundCount = 0;
                
                data.elements.forEach(element => {
                    let lat, lon;
                    
                    // Nodes have 'lat' and 'lon' directly
                    if (element.type === 'node') {
                        lat = element.lat;
                        lon = element.lon;
                    } 
                    // Ways/Areas use 'center'
                    else if (element.type === 'way' && element.center) {
                        lat = element.center.lat;
                        lon = element.center.lon;
                    } else {
                        return; // Skip if no valid location
                    }

                    // Extract name and type for the popup
                    const name = element.tags.name || 'Ù†Ø§Ù…Ø´Ø®Øµ';
                    const amenity = element.tags.amenity || 'Ø³Ø±ÙˆÛŒØ³ Ù†Ø§Ù…Ø´Ø®Øµ';
                    const type = element.tags.name ? amenity : 'ÙØ§Ù‚Ø¯ Ù†Ø§Ù…';
                    
                    const marker = L.marker([lat, lon]);
                    marker.bindPopup(`
                        <p class="font-bold">${name}</p>
                        <p class="text-sm">Ù†ÙˆØ¹ Ø³Ø±ÙˆÛŒØ³: ${type}</p>
                        <p class="text-xs text-gray-500">Ù…Ù†Ø¨Ø¹: OSM (Overpass)</p>
                    `);
                    markers.addLayer(marker);
                    foundCount++;
                });

                // Update summary box
                resultSummary.classList.remove('hidden');
                resultSummary.innerHTML = `
                    <strong class="text-blue-700">${groupName}</strong>: 
                    <span class="font-semibold">${foundCount} Ù…Ú©Ø§Ù†</span> ÛŒØ§ÙØª Ø´Ø¯. 
                    <p class="text-xs text-gray-600 mt-1">
                    Ø´Ø§Ù…Ù„ ØªÚ¯â€ŒÙ‡Ø§ÛŒÛŒ Ù…Ø§Ù†Ù†Ø¯: ${tags.map(t => `<span class="italic">${t.split('=')[1]}</span>`).join(', ')}
                    </p>
                `;
                
                // If markers were found, adjust map to fit them
                if (foundCount > 0) {
                    map.fitBounds(markers.getBounds(), { padding: [50, 50] });
                } else {
                    resultSummary.innerHTML = `<strong class="text-orange-500">${groupName}:</strong> Ù…ØªØ£Ø³ÙØ§Ù†Ù‡ØŒ Ù‡ÛŒÚ† Ù…Ú©Ø§Ù†ÛŒ Ø¨Ø§ ØªÚ¯â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¯Ø± Ø§ÛŒÙ† Ù…Ø­Ø¯ÙˆØ¯Ù‡ ÛŒØ§ÙØª Ù†Ø´Ø¯.`;
                }

            } catch (error) {
                loadingIndicator.classList.add('hidden');
                resultSummary.classList.remove('hidden');
                resultSummary.innerHTML = `<strong class="text-red-600">Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø§Ø¯Ù‡:</strong> Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø³Ø±ÙˆØ± Overpass Ø´Ù„ÙˆØº Ø¨Ø§Ø´Ø¯. Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.`;
                console.error("Overpass API Error:", error);
            }
        }

        // --- Event Listeners ---

        // 1. Location Search
        searchLocationButton.addEventListener('click', async () => {
            const location = locationInput.value.trim();
            if (location) {
                await geocodeLocation(location);
            }
        });
        
        locationInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchLocationButton.click();
            }
        });

        // 2. Service Group Search (New)
        serviceGroupButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove active state from all buttons
                serviceGroupButtons.forEach(btn => btn.classList.remove('ring-4', 'ring-opacity-50', 'ring-offset-2', 'ring-current'));
                
                // Add active state to the clicked button
                button.classList.add('ring-4', 'ring-opacity-50', 'ring-offset-2', 'ring-current');

                const groupName = button.getAttribute('data-group');
                const tags = UNICEF_TAGS[groupName];

                if (tags) {
                    fetchOSMData(tags, button.textContent.trim());
                }
            });
        });

        // Initial setup for the map (optional: try to get user location or set a default view)
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition((position) => {
                map.setView([position.coords.latitude, position.coords.longitude], 13);
            }, (error) => {
                console.warn("Geolocation failed. Using default view.");
            });
        }
    </script>

</body>
</html>
